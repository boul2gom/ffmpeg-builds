name: Github CI - Automatic weekly release

on:
  schedule:
    - cron: '0 0 * * 1'
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force the release even if no updates are found'
        required: false
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  check_updates:
    name: âœ… Check for newer versions
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    outputs:
      has_updates: ${{ steps.check_version.outputs.has_updates }}
      version: ${{ steps.check_version.outputs.version }}
      changelog: ${{ steps.check_version.outputs.changelog }}

    steps:
      - name: ðŸ“ Check out the repository
        uses: actions/checkout@v6.0.2
        with:
          fetch-depth: 100

      - name: ðŸ” Check for ffmpeg version updates
        id: check_version
        uses: actions/github-script@v8.0.0
        with:
          script: |
            try {
              const vcpkg_response = await github.rest.repos.getContent({
                owner: 'microsoft',
                repo: 'vcpkg',
                path: 'ports/ffmpeg/vcpkg.json',
                ref: 'master'
              });
              
              const vcpkg_content = Buffer.from(vcpkg_response.data.content, 'base64').toString();
              const vcpkg_json = JSON.parse(vcpkg_content);
              const vcpkg_version = vcpkg_json.version;
              console.log(`ðŸ“¦ Latest vcpkg ffmpeg version: ${vcpkg_version}`);
              
              let latest_release_version = "0.0.0";
              let latest_release_date = null;
              try {
                const releases = await github.rest.repos.getLatestRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                latest_release_version = releases.data.tag_name;
                latest_release_date = releases.data.published_at;
                console.log(`ðŸ·ï¸ Latest repo release: ${latest_release_version} (${latest_release_date})`);
              } catch (e) {
                console.log("âš ï¸ No releases found, assuming 0.0.0");
              }
              
              const has_updates = (vcpkg_version !== latest_release_version) || ("${{ inputs.force_release }}" === "true");
              
              if ("${{ inputs.force_release }}" === "true") {
                 console.log("â„¹ï¸ Force release enabled.");
              }
              
              console.log(`ðŸš€ Has updates? ${has_updates}`);
              
              let changelog = "";
              if (latest_release_version === "0.0.0" || !latest_release_date) {
                console.log("âš ï¸ First release or no previous release found. Skipping detailed changelog.");
                changelog = "Initial release or manual build.";
              } else {
                try {
                  console.log(`ðŸ” Fetching commits since ${latest_release_date}...`);
                  const commits = await github.rest.repos.listCommits({
                    owner: 'microsoft',
                    repo: 'vcpkg',
                    path: 'ports/ffmpeg',
                    since: latest_release_date
                  });
                  
                  changelog = "### ðŸ“œ Vcpkg Changes\n";
                  const commit_list = commits.data.slice(0, 20);
                  
                  if (commit_list.length === 0) {
                     changelog += "No changes found in vcpkg ports/ffmpeg since last release.\n";
                  } else {
                      for (const commit of commit_list) {
                        const message = commit.commit.message.split('\n')[0];
                        const author = commit.commit.author.name;
                        const date = new Date(commit.commit.author.date).toISOString().split('T')[0];
                        changelog += `- ${date}: ${message} (${author})\n`;
                      }
                  }
                  console.log("âœ… Fetched changelog");
                } catch (e) {
                  console.log(`âš ï¸ Failed to fetch changelog: ${e.message}`);
                  changelog = "Failed to fetch changelog.";
                }
              }

              core.setOutput("version", vcpkg_version);
              core.setOutput("has_updates", has_updates.toString());
              core.setOutput("changelog", changelog);
              
            } catch (error) {
              core.setFailed(`Failed to check versions: ${error.message}`);
            }

  pack_binaries:
    needs: check_updates
    if: ${{ needs.check_updates.outputs.has_updates == 'true' }}
    name: ðŸ“¦ Build ${{ matrix.target-os }}-${{ matrix.target-arch }}
    
    strategy:
      fail-fast: false
      matrix:
        target-os: [windows, linux, osx]
        target-arch: [arm64, x86, x64]
        include:
          - target-os: windows
            os: windows-latest
          - target-os: linux
            os: ubuntu-latest
          - target-os: osx
            os: macos-latest
        exclude:
          # macOS x86 est obsolÃ¨te
          - target-os: osx
            target-arch: x86

    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
      actions: write
      packages: write

    env:
      VCPKG_BINARY_SOURCES: "clear;nuget,GitHub,readwrite"

    steps:
      - name: âš™ï¸ Export GitHub Actions Cache environment variables
        uses: actions/github-script@v8.0.0
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: ðŸ“ Checkout self
        uses: actions/checkout@v6.0.2
        with:
          path: self/

      - name: ðŸ“ Checkout vcpkg
        uses: actions/checkout@v6.0.2
        with:
          repository: microsoft/vcpkg
          ref: master
          path: vcpkg/

      - name: ðŸ—ƒï¸ Cache vcpkg executable
        uses: actions/cache@v5.0.3
        with:
          path: |
            vcpkg/vcpkg
            vcpkg/vcpkg.exe
          key: ${{ runner.os }}-vcpkg-exe-${{ hashFiles('vcpkg/.git/HEAD') }}

      - name: ðŸ—ƒï¸ Cache vcpkg downloads
        uses: actions/cache@v5.0.3
        with:
          path: vcpkg/downloads
          key: ${{ matrix.target-os }}-${{ matrix.target-arch }}-vcpkg-downloads-${{ hashFiles('self/vcpkg.json') }}
          restore-keys: |
            ${{ matrix.target-os }}-${{ matrix.target-arch }}-vcpkg-downloads-

      - name: ðŸ”§ Configure NuGet credentials
        shell: bash
        run: |
          dotnet nuget add source \
            "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" \
            --name "GitHub" \
            --username "${{ github.actor }}" \
            --password "${{ secrets.GITHUB_TOKEN }}" \
            --store-password-in-clear-text

      - name: ðŸ› ï¸ Bootstrap vcpkg
        shell: bash
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
            ./vcpkg/bootstrap-vcpkg.bat
          else
            ./vcpkg/bootstrap-vcpkg.sh
          fi

      - name: ðŸ“Œ Install dependencies
        shell: bash
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
            ./self/install-deps.ps1
          else
            ./self/install-deps.sh
          fi

      - name: ðŸ—ï¸ Build ffmpeg
        shell: bash
        run: |
          ./vcpkg/vcpkg install \
            --recurse \
            --triplet ${{ matrix.target-arch }}-${{ matrix.target-os }} \
            --x-manifest-root self/

      - name: ðŸ“¤ Upload build logs
        uses: actions/upload-artifact@v6.0.0
        if: failure()
        with:
          name: logs-${{ matrix.target-os }}-${{ matrix.target-arch }}
          path: vcpkg/buildtrees/**/*.log
          if-no-files-found: ignore

      - name: ðŸ“¤ Upload build output
        uses: actions/upload-artifact@v6.0.0
        with:
          name: ffmpeg-${{ matrix.target-os }}-${{ matrix.target-arch }}
          path: self/vcpkg_installed/${{ matrix.target-arch }}-${{ matrix.target-os }}/tools/ffmpeg/
          if-no-files-found: error

  release_binaries:
    name: ðŸš€ Create Release & Upload
    needs: [check_updates, pack_binaries]
    if: ${{ needs.check_updates.outputs.has_updates == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: ðŸ“… Get current date
        id: date
        run: echo "date=$(date +'%Y-%m-%d %H::%M')" >> $GITHUB_ENV

      - name: ðŸ“¥ Download all build artifacts
        uses: actions/download-artifact@v7.0.0
        with:
          path: artifacts

      - name: ðŸ“¦ Archive artifacts
        run: |
          mkdir release_assets
          for dir in artifacts/ffmpeg-*; do
            if [ -d "$dir" ]; then
              dirname=$(basename "$dir")
              echo "Packaging $dirname..."
              
              if [[ "$dirname" != *"windows"* ]]; then
                 chmod +x "$dir/ffmpeg" || true
              fi
              
              pushd "$dir"
              zip -r "../../release_assets/$dirname.zip" .
              popd
            fi
          done
          ls -l release_assets/
          
          echo "ðŸ§® Calculating Checksums..."
          pushd release_assets
          sha256sum *.zip > ../checksums.sha256
          popd
          
          echo "CHECKSUMS<<EOF" >> $GITHUB_ENV
          cat checksums.sha256 >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: ðŸš€ Create Release & Upload Assets
        uses: softprops/action-gh-release@v2.5.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.check_updates.outputs.version }}
          name: ðŸ”– ${{ needs.check_updates.outputs.version }}
          draft: false
          prerelease: false
          files: release_assets/*
          fail_on_unmatched_files: true
          body: |
            ## ðŸš€ FFmpeg v${{ needs.check_updates.outputs.version }}
            
            Automated build triggered by update in `vcpkg`. Built on ${{ env.date }}

            ${{ needs.check_updates.outputs.changelog }}
            
            ### ðŸ“¦ Artifacts & Checksums
            ```text
            ${{ env.CHECKSUMS }}
            ```